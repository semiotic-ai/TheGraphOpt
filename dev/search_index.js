var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This section documents all functions not documented elsewhere","category":"page"},{"location":"api/","page":"API","title":"API","text":"TheGraphOpt.x\nTheGraphOpt.x!\nTheGraphOpt.η\nTheGraphOpt.ϵ\nTheGraphOpt.maybeminimize!\nTheGraphOpt.shouldstop\nTheGraphOpt.iteration","category":"page"},{"location":"api/#TheGraphOpt.x","page":"API","title":"TheGraphOpt.x","text":"x(g::GradientDescent)\nx(g::GradientDescent, v)\n\nThe current best guess for the solution. If using the setter, v is the new value.\n\nThe setter is not in-place. See TheGraphOpt.x!.\n\n\n\n\n\n","category":"function"},{"location":"api/#TheGraphOpt.x!","page":"API","title":"TheGraphOpt.x!","text":"x!(g::GradientDescent, v)\n\nIn-place setting of g.x to v\n\nSee TheGraphOpt.x.\n\n\n\n\n\n","category":"function"},{"location":"api/#TheGraphOpt.η","page":"API","title":"TheGraphOpt.η","text":"η(g::GradientDescent)\nη(g::GradientDescent, v)\n\nThe learning rate/step size. If using the setter, v is the new value.\n\nThe setter is not in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/#TheGraphOpt.ϵ","page":"API","title":"TheGraphOpt.ϵ","text":"ϵ(g::GradientDescent)\nϵ(g::GradientDescent, v)\n\nThe tolerance. If using the setter, v is the new value.\n\nThe setter is not in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/#TheGraphOpt.maybeminimize!","page":"API","title":"TheGraphOpt.maybeminimize!","text":"maybeminimize!(f::Function, a::OptAlgorithm, op::Function)\n\nMinimize f using a, which calls op for updating a.x.\n\nThis function may be in-place. Don't use it directly unless you know what you're doing. This function is unexported.\n\nwarning: Warning\nIf you don't provide any hook with the IsStoppingCondition trait, this will loop forever.\n\n\n\n\n\n","category":"function"},{"location":"api/#TheGraphOpt.shouldstop","page":"API","title":"TheGraphOpt.shouldstop","text":"shouldstop(hs::AbstractVecOrTuple{H}, a::OptAlgorithm; locals...)\n\nMap over the hooks hs to check for stopping conditions.\n\nThis performs an OR operation if there are multiple hooks that have the TheGraphOpt.IsStoppingCondition trait.\n\n\n\n\n\n","category":"function"},{"location":"api/#TheGraphOpt.iteration","page":"API","title":"TheGraphOpt.iteration","text":"iteration(f::Function, a::OptAlgorithm)\n\nOne iteration of a on the function f.\n\nThis function is unexported.\n\n\n\n\n\n","category":"function"},{"location":"hooks/#hooks","page":"Hooks","title":"Hooks","text":"","category":"section"},{"location":"hooks/","page":"Hooks","title":"Hooks","text":"Hooks enable you to dynamically choose to inject functionality into algorithms. Some hooks are mandatory for certain algorithms, such as having a hook with the TheGraphOpt.IsStoppingCondition trait when using TheGraphOpt.GradientDescent. Others are purely there for you to use at your discretion. In this section, we'll take you through Traits, Using Predefined Hooks and how to Create Custom Hooks.","category":"page"},{"location":"hooks/#Traits","page":"Hooks","title":"Traits","text":"","category":"section"},{"location":"hooks/","page":"Hooks","title":"Hooks","text":"Hooks have traits. This is how our code knows when to execute which hook. For example, the code will execute a hook that has the TheGraphOpt.IsStoppingCondition trait when evaluating whether it has finished optimising. A full list of traits follows.","category":"page"},{"location":"hooks/#StopTrait","page":"Hooks","title":"StopTrait","text":"","category":"section"},{"location":"hooks/","page":"Hooks","title":"Hooks","text":"This trait tells the code if it should execute a hook when checking stopping conditions. By default, the code automatically gives all hooks the TheGraphOpt.IsNotStoppingCondition trait except in certain situations, which are explicitly documented with the hooks in question. We decide to stop code execution on an OR basis. This means that if any hook with TheGraphOpt.IsStoppingCondition returns true, the code breaks out of the optimisation loop. Hooks with this trait must implement TheGraphOpt.stophook.","category":"page"},{"location":"hooks/","page":"Hooks","title":"Hooks","text":"TheGraphOpt.StopTrait\nTheGraphOpt.IsStoppingCondition\nTheGraphOpt.IsNotStoppingCondition\nTheGraphOpt.stophook","category":"page"},{"location":"hooks/#TheGraphOpt.StopTrait","page":"Hooks","title":"TheGraphOpt.StopTrait","text":"Abstract type for stopping conditions traits\n\n\n\n\n\n","category":"type"},{"location":"hooks/#TheGraphOpt.IsStoppingCondition","page":"Hooks","title":"TheGraphOpt.IsStoppingCondition","text":"Exhibited by hooks that are stopping conditions. Stopping condition hooks must emit a boolean value when TheGraphOpt.stophook is called. If multiple hooks meet IsStoppingCondition are instantiated at the same time, we assume that they are meant to be OR'ed, so if any of them is true, optimisation is finished. For more complex behaviour, consider defining a more complex function using a single StopWhen.\n\nTo set this trait for a hook, run\n\njulia> StopTrait(::Type{MyHook}) = IsStoppingCondition()\n\n\n\n\n\n","category":"type"},{"location":"hooks/#TheGraphOpt.IsNotStoppingCondition","page":"Hooks","title":"TheGraphOpt.IsNotStoppingCondition","text":"Exhibited by hooks that are not stopping conditions. This is the default case. You should not have to set it manually for any hooks.\n\n\n\n\n\n","category":"type"},{"location":"hooks/#TheGraphOpt.stophook","page":"Hooks","title":"TheGraphOpt.stophook","text":"stophook(h::::IsStoppingCondition, a::OptAlgorithm; locals...)\n\nRaise an error if the hook is a stopping condition but has not implemented stophook.\n\n\n\n\n\nstophook(h::::(!IsStoppingCondition), a::OptAlgorithm; locals...)\n\nIf the hook isn't a stopping condition, it shouldn't be considered in the OR, so return false.\n\n\n\n\n\nstophook(h::StopWhen, a::OptAlgorithm; locals...)\n\nCall h.f on a and ;locals.\n\n\n\n\n\n","category":"function"},{"location":"hooks/#Using-Predefined-Hooks","page":"Hooks","title":"Using Predefined Hooks","text":"","category":"section"},{"location":"hooks/","page":"Hooks","title":"Hooks","text":"Hooks always descend from the same abstract type.","category":"page"},{"location":"hooks/","page":"Hooks","title":"Hooks","text":"TheGraphOpt.Hook","category":"page"},{"location":"hooks/#TheGraphOpt.Hook","page":"Hooks","title":"TheGraphOpt.Hook","text":"Abstract type for hooks.\n\n\n\n\n\n","category":"type"},{"location":"hooks/","page":"Hooks","title":"Hooks","text":"Generally speaking, pre-defined hooks won't exhibit any positive traits unless explicitly documented otherwise. This serves two purposes. Firstly, it prevents any unexpected behaviour when the code executes. Secondly, it gives you more flexibility when choosing where you want a hook to be executed.","category":"page"},{"location":"hooks/","page":"Hooks","title":"Hooks","text":"warning: Warning\nThis section is incomplete! We will fill this out more once we have more traits and hooks to work with.","category":"page"},{"location":"hooks/","page":"Hooks","title":"Hooks","text":"note: Note\nWe recommend you read the below StopWhen section as it explains details that we won't cover in the later sections since it'd be too repetitive.","category":"page"},{"location":"hooks/#StopWhen","page":"Hooks","title":"StopWhen","text":"","category":"section"},{"location":"hooks/","page":"Hooks","title":"Hooks","text":"This hook has the TheGraphOpt.IsStoppingCondition trait. To use it, you would specify a function that returns a boolean value. If said value is true, then the code breaks out of the optimisation loop.","category":"page"},{"location":"hooks/","page":"Hooks","title":"Hooks","text":"Let's take an example from our tests to demonstrate how to specify this hook. We'll also implement a dummy optimisation function that just implements a counter for illustration purposes.","category":"page"},{"location":"hooks/","page":"Hooks","title":"Hooks","text":"julia> using TheGraphOpt\njulia> struct FakeOptAlg <: TheGraphOpt.OptAlgorithm end\njuila> a = FakeOptAlg()\njulia> function counter(h, a)\n            i = 0\n            while !shouldstop(h, a; Base.@locals()...)\n                i += 1\n            end\n            return i\n        end\njulia> h = StopWhen((a; locals...) -> locals[:i] ≥ 5, Dict())  # Stop when i ≥ 5\njulia> i = counter((h,), a)\n5","category":"page"},{"location":"hooks/","page":"Hooks","title":"Hooks","text":"One thing you may not have seen is Base.@locals. This takes variables from the local scope (in this case, from the counter scope), and tracks them as a dictionary of symbols. Thus, since i is a local variable inside of counter, :i becomes a key in the Base.@locals dictionary. We pass this dictionary to the anonymouse function stored by StopWhen. Then, we can use locals[:i] to get the value of i from the counter scope and check it against some condition. This is a powerful trick you may find yourself using a lot when dealing with hooks.","category":"page"},{"location":"hooks/","page":"Hooks","title":"Hooks","text":"TheGraphOpt.StopWhen","category":"page"},{"location":"hooks/#TheGraphOpt.StopWhen","page":"Hooks","title":"TheGraphOpt.StopWhen","text":"StopWhen(f::Function)\n\nStops optimisation when some condition is met.\n\nThe condition is set by f. Note that f gets access to variables in the TheGraphOpt.minimize scope. This means, for example, that it can use locals[:z] to compute residuals. This has the TheGraphOpt.IsStoppingCondition trait.\n\n\n\n\n\n","category":"type"},{"location":"hooks/#Create-Custom-Hooks","page":"Hooks","title":"Create Custom Hooks","text":"","category":"section"},{"location":"hooks/","page":"Hooks","title":"Hooks","text":"When you create a custom hook, you need to follow three steps. The first is that you need to descend from TheGraphOpt.Hook.","category":"page"},{"location":"hooks/","page":"Hooks","title":"Hooks","text":"julia> using TheGraphOpt\njulia> struct MyHook <: Hook end","category":"page"},{"location":"hooks/","page":"Hooks","title":"Hooks","text":"The second is that you need to ensure that you specify which traits you want that hook to exhibit. For example, let's say MyHook is a stopping condition. You'd want to implement.","category":"page"},{"location":"hooks/","page":"Hooks","title":"Hooks","text":"julia> StopTrait(::Type{MyHook}) = IsStoppingCondition()","category":"page"},{"location":"hooks/","page":"Hooks","title":"Hooks","text":"Finally, if you need non-default behaviour for when the hook executes, you'll need to implement whatever function(s) the code calls for that trait-type. For IsStoppingCondition, that's stophook. Say we want MyHook to immediately cause optimisation to finish. We'd implement","category":"page"},{"location":"hooks/","page":"Hooks","title":"Hooks","text":"julia> stophook(h::MyHook, a::TheGraphOpt.OptAlgorithm; locals...) = true","category":"page"},{"location":"hooks/","page":"Hooks","title":"Hooks","text":"That's it! As long as your follow those three steps, you should be able to implement whatever hook you want!","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = TheGraphOpt","category":"page"},{"location":"#TheGraphOpt","page":"Home","title":"TheGraphOpt","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package implements optimisation algorithms for use within simulation and production. For the most part, your workflow should look something like","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using TheGraphOpt\njulia> using LinearAlgebra\njulia> f(x) = sum(x .^ 2)  # Specify function to optimise as min f(x)\njulia> a = GradientDescent(;\n            x=[100.0, 50.0],  # Specify parameters for optimisation\n            η=1e-1,\n            ϵ=1e-6,\n            hooks=[StopWhen((a; kws...) -> norm(x(a) - kws[:z]) < ϵ(a))],  # hook stops opt when residual is below ϵ.\n        )\njulia> sol = minimize!(f, a)  # Optimise\njulia> @show TheGraphOpt.x(sol)  # Print out the optimal value\n2-element Vector{Float64}:\n 3.4163644416613304e-6\n 1.6909278549636878e-6","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Make sure you've installed Julia 1.8 or greater.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is hosted on SemioticJLRegistry. To add this package, first add the registry to your Julia installation. Then, install this package by running ] add TheGraphOpt from the Julia REPL.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]registry add https://github.com/semiotic-ai/SemioticJLRegistry\njulia> ]add TheGraphOpt","category":"page"},{"location":"algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"This section will introduce you to the basic workflow that you'll use to optimise functions, as well as the algorithms we've implemented.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Generally speaking, there are two parts to optimising. The first is to specify the function you want to optimise. Say,","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"julia> f(x) = sum(x .^ 2)","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Then you want to create a Hook with the TheGraphOpt.IsStoppingCondition trait. Else, optimisation will get stuck in an infinite loop.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"julia> using LinearAlgebra\njulia> h = StopWhen((a; locals...) -> norm(x(a) - locals[:z]) < ϵ(a))  # Stop when the residual is less than the tolerance","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Then, you want to choose the algorithm you want to use for minimisation and specify its parameters.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"julia> a = GradientDescent(; x=[100.0, 50.0], η=1e-1, ϵ=1e-6, hooks=[h,])  # Specify parameters for optimisation","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Finally, you'll run minimize! or minimize.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"julia> sol = minimize!(f, a)  # Optimise","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"TheGraphOpt.minimize!\nTheGraphOpt.minimize","category":"page"},{"location":"algorithms/#TheGraphOpt.minimize!","page":"Algorithms","title":"TheGraphOpt.minimize!","text":"minimize!(f::Function, a::OptAlgorithm)\n\nMinimize f using a.\n\nDoes in-place updates of a.x. This will generally be more performant than TheGraphOpt.minimize. However, there are cases in which this will be worse, so we provide both.\n\nwarning: Warning\nIf you don't provide any hook with the IsStoppingCondition trait, this will loop forever.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#TheGraphOpt.minimize","page":"Algorithms","title":"TheGraphOpt.minimize","text":"minimize(f::Function, a::OptAlgorithm)\n\nMinimize f using a.\n\nThis will generally be less performant than TheGraphOpt.minimize!. However, there are cases in which this will be better, so we provide it as an option.\n\nwarning: Warning\nIf you don't provide any hook with the IsStoppingCondition trait, this will loop forever.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"sol here is a struct containing various metadata. If you only care about the optimal value of x, then grab it using","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"julia> TheGraphOpt.x(sol)","category":"page"},{"location":"algorithms/#Algorithms-2","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"algorithms/#Gradient-Descent","page":"Algorithms","title":"Gradient Descent","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"From Wikipedia:","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"[Gradient Descent]... is a first-order iterative optimization algorithm for finding a local minimum of a differentiable function. The idea is to take repeated steps in the opposite direction of the gradient (or approximate gradient) of the function at the current point, because this is the direction of steepest descent. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"If the function we're optimising f is convex, then a local minimum is also a global minimum. The update rule for gradient descent is x_n+1=x_n - ηf(x_n).","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"TheGraphOpt.GradientDescent","category":"page"},{"location":"algorithms/#TheGraphOpt.GradientDescent","page":"Algorithms","title":"TheGraphOpt.GradientDescent","text":"GradientDescent{\n    T<:Real,H<:Hook,V<:AbstractVector{T},S<:AbstractVecOrTuple{H}\n} <: OptAlgorithm\n\nSpecifies parameters for gradient descent learning.\n\nFields\n\nη::T is the learning rate/step size.\nx::V is the current best guess for the solution.\nϵ::T is the tolerance.\nhooks::S are the hooks\n\n\n\n\n\n","category":"type"}]
}
